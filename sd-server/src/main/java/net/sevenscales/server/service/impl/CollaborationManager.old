package net.st.shareddesign.server.service.impl;

import net.st.shareddesign.domain.api.IEvent;
import net.st.shareddesign.domain.api.IMessage;
import net.st.shareddesign.domain.api.IUser;
import net.st.shareddesign.domain.dto.ContactDTO;
import net.st.shareddesign.domain.dto.SignOnEventDTO;
import net.st.shareddesign.domain.dto.SignOutEventDTO;
import net.st.shareddesign.server.ApplicationContext;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

public class CollaborationManager {
  private Map<String, UserInfo> authentications = new HashMap<String, UserInfo>();
  private int waitingThreadsCount;
  
  public class UserInfo {
    IUser user;
    String authenticationToken;
    boolean waiting;
    List<IEvent> events = new ArrayList<IEvent>();
  }

  public void broadcast(IEvent event, UserInfo except) {
    // loop users
    Set<Map.Entry<String, UserInfo>> entries = authentications.entrySet();
    for (Map.Entry<String, UserInfo> e : entries) {
      UserInfo ui = e.getValue();      
      // notify everybody else than except
//      if (ui != except) {
        // add event to user       
        synchronized (ui) {
          ui.events.add(event);
          // notify
          ui.notifyAll();
        }
//      }
    }
  }
  
  public void sendMessage(IUser user, IMessage message) {
    // resolve receiver
    // create event
    // add event to receiver
    // notifyAll receiver
  }

  public UserInfo getCurrentUser(String sessionId) {
    return authentications.get(sessionId);
//    Cookie[] cookies = ApplicationContext.getInstance().getThreadLocalRequest().
//      getCookies();
//    
//    String token = "";
//    for (Cookie c : cookies) {
//      if (c.getName().equals(SdCookieConstants.AUTHENTICATION_TOKEN)) {
//        URI uri = URI.create(c.getValue());
//        token = uri.getPath();
//        break;
//      }
//    }
//    return authentications.get(token);
  }

  private void currentOtherUsers(UserInfo userInfo) {
    for (Entry<String, UserInfo> e : authentications.entrySet()) {
      if (e.getValue() != userInfo) {
        // do not add me
        SignOnEventDTO online = new SignOnEventDTO();
        online.user = new ContactDTO();
        online.user.setUserId(e.getValue().user.getUserId());
        userInfo.events.add(online);
      }
    }
  }

  private void printCurrentUsers() {
    Set<String> keys = authentications.keySet();
    for (String key : keys) {
      ApplicationContext.logger.info(authentications.get(key).user.getUserId());
    }
  }

  public void login(String sessionId, IUser user) {
    UserInfo userInfo = new UserInfo();
    userInfo.user = user;
    
    ApplicationContext.logger.debug("login: " + sessionId);
 
    synchronized (authentications) {
      authentications.put(sessionId, userInfo);
      printCurrentUsers();
    }
    
    // fill in current users in the system
    // to be returned for login user when requested
    currentOtherUsers(userInfo);
    
    // create sign on event for new user
    SignOnEventDTO event = new SignOnEventDTO();
    event.user = new ContactDTO();
    event.user.setUserId(userInfo.user.getUserId());
  
    // broadcast others that I logged in
    broadcast(event, userInfo);
  }

  public void logout(String sessionId) {
    UserInfo ui = getCurrentUser(sessionId);
    
    ApplicationContext.logger.debug("logout: " + sessionId);

    synchronized (authentications) {
      authentications.remove(sessionId);
    }
    
    SignOutEventDTO out = new SignOutEventDTO();
    out.contact = new ContactDTO();
    out.contact.setUserId(ui.user.getUserId());    
    
    // notify all of logout event
    broadcast(out, ui);
  }

  public IUser relogin(String sessionId) {
    IUser result = null;
    for (Map.Entry<String, UserInfo> entry : authentications.entrySet()) {
      if (entry.getKey().equals(sessionId)) {
        result = entry.getValue().user;
        logout(sessionId);
        login(sessionId, entry.getValue().user);
        // fill other users in the system
        // to be requested later
//        currentOtherUsers(entry.getValue());
        break;
      }
    }
    
    ApplicationContext.logger.debug("Relogin: " + result + sessionId);
    return result;
  }

  public List<IEvent> getEvents(String sessionId) {
    // get current user
    UserInfo ui = getCurrentUser(sessionId);
    ApplicationContext.logger.debug("authenticated: "+ authentications.size());
    
    // if no events => sleep
    if (ui.events.size() == 0) {
      try {
        synchronized (ui) {
          ApplicationContext.logger.debug("getEvents wait: " + sessionId);
          ApplicationContext.logger.debug("waiting threads  " + ++waitingThreadsCount);
          ui.waiting = true;
          ui.wait(30000);
          ui.waiting = false;
          ApplicationContext.logger.debug("waiting threads  " + --waitingThreadsCount);
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    
    ApplicationContext.logger.debug("getEvents result: " + sessionId);

    // return events
    List<IEvent> result = null;    
    synchronized (ui) {
      result = ui.events;      
      // clear events
      ui.events = new ArrayList<IEvent>();
    }
    return result;
  }

  public void sendEvent(String sessionId, ContactDTO to, IEvent event) {
    UserInfo ui = getCurrentUser(sessionId);
    
    // TODO: currently event sent to everybody
    // change to send event to only selected contacts...
    broadcast(event, ui);
  }

}
